//  Copyright 2017, Marton Kanasz-Nagy, All rights reserved.
//  kanasz.nagy.marton@gmail.com
//
//  MC_holePropagationQState.cpp
//  
//
//  Created by Marton Kanasz-Nagy on 10/17/16.
//
//

#include "MC_holePropagationQState.hpp"


// --------------------------------------------
// HOLE PROPAGATION IN AN INITIAL QUANTUM STATE
// --------------------------------------------

// constructor
holePropagationQState::holePropagationQState(void) : holePropagation() {
    QState.setCoefficient(complex<double> (1., 0.));
    this->generateSaveFilenames("Random");
    this->saveQState();
}

// constructor
holePropagationQState::holePropagationQState(double t, int nFwdPaths, const singleHoleQState &inputQState, string nameOfState, bool spinCorrQ) : holePropagation(t, nFwdPaths, spinCorrQ)
{
    this->QState = inputQState;
    this->QState.setCoefficient(complex<double> (1., 0.));
    this->generateSaveFilenames(nameOfState);
    this->saveQState();
}

// destructor
holePropagationQState::~holePropagationQState(void) {
    
};

// resets time, #runs, #paths, QState, and clears all values from the bins
void holePropagationQState::resetQState(double t, int nFwdPaths, const singleHoleQState & newQState, string nameOfState) {
    this->holePropagation::reset(t, nFwdPaths);
    this->QState = newQState;
    this->QState.setCoefficient(complex<double> (1., 0.));
    this->generateSaveFilenames(nameOfState);
    this->saveQState();
};

// generate new singleHoleQStateContainer and updates the bins using holePropagationQState::update() (Overwritten function!)
void holePropagationQState::run(void) {
    // Generate path container
    pathContainer pathCont;
    
    // Fill path container with randomly generated paths
    pathCont.fill(this->tHole, this->nPaths);
    
    // Run simulation
    this->run(pathCont);
}

// same as run(void), just does not automatically generate the container, but uses the pathContainer 'pC' instead
void holePropagationQState::run(const pathContainer & pathCont) {
    // Calculate the contribution of each pair of path to the transition probability
    this->update(pathCont);
    
    // Update number of runs
    (this->nRuns)++;
}

// Calculates the contribution of each path in pathContainer to the transition probabilities,
// and it updates transProbsBins[]
void holePropagationQState::update(const pathContainer & pathCont) {
    int iSite;                                  // site index
    set<singleHoleQState>::iterator it;         // iterator of pathData elements within cont[iSite]
    singleHoleQStateContainer qStateCont;       // bin storing the quantum states generated by the paths arriving at each site
    
    // Print out memory usage
    cout << endl << endl;
    cout << "Running simulation " << (this->nRuns + 1) << endl;
    cout << "Number of pathData bins: " << pathCont.getNumberOfBins() << endl;
    cout << "Estimated memory of path container: " << setprecision(2) << fixed << (pathCont.getMemoryBytes()/(1024.*1024.)) << " MB" << endl;

    // Permute 'this->QState' with all the paths in 'pathCont'
    qStateCont.fill(pathCont, this->QState);
    
    // Loop over all sites
    for(iSite=0; iSite<(this->nSites); iSite++) {
        for(it=qStateCont[iSite].begin(); it!=qStateCont[iSite].end(); ++it) {
            this->update(*it);
        }
    }
}

// Updates the bins with contributions from the quantumState 'qS'
double holePropagationQState::update(const singleHoleQState &qS) {
    // Check the coefficient is zero. Then, we don't have to do anything
    if(qS.getCoefficient() == complex<double>(0.,0.)) {
        return 0.;
    }
    
    long double contribution;   // contribution of this quantum state to the transition probability bins
    int holePosition;           // position of the hole
    
    // Get position of the hole
    holePosition = qS.getHolePosition();
    
    // Update transition probability bins
    complex<long double> tmp;
    tmp = qS.getCoefficient();
    tmp = conj(tmp) * tmp;
    contribution = tmp.real();
    this->transProbsBins[holePosition] += contribution;
    
    // Update spin correlation bins
    if(this->calcSpinCorrelationsQ) {
        int i1,i2;                  // iterators
        int i1Hole, i2Hole;         // iterators
        int x,y,xHole,yHole;        // coordinates
        xHole = indexToX(holePosition);
        yHole = indexToY(holePosition);
        
        for(i1=0; i1<this->nSites; i1++) {
            for(i2=0; i2<this->nSites; i2++) {
                LabFrameSpinCorrelationBins[i1][i2] += qS[i1]*qS[i2]*contribution;
            }
        }
        
        int holeFrameSiteIndices[this->nSites];
        for(i1=0; i1<this->nSites; i1++) {
            x = indexToX(i1);
            y = indexToY(i1);
            holeFrameSiteIndices[i1] = coordToIndex(x-xHole, y-yHole);
        }
        for(i1=0; i1<this->nSites; i1++) {
            i1Hole = holeFrameSiteIndices[i1];
            for(i2=0; i2<this->nSites; i2++) {
                i2Hole = holeFrameSiteIndices[i2];
                HoleFrameSpinCorrelationBins[i1Hole][i2Hole] += qS[i1]*qS[i2]*contribution;
            }
        }
    }
    
    return contribution;
}

// calculate spin correlations using LabFrameSpinCorrelationBins
// (Overwritten function!)
void holePropagationQState::calculateLabFrameSpinCorrelationFn (vector< vector<double> > &labFrameSpinCorrelationFn) const {
    long double total = 0.L;
    long double invTotal;
    int i,j;
    
    // Resize array and make sure it does not waste memory
    labFrameSpinCorrelationFn.reserve(this->nSites);
    labFrameSpinCorrelationFn.resize(this->nSites);
    for(i=0; i<this->nSites; i++) {
        labFrameSpinCorrelationFn[i].reserve(this->nSites);
        labFrameSpinCorrelationFn[i].resize(this->nSites);
    }
    
    // Calculate spin correlations only if you have to
    if(!this->calcSpinCorrelationsQ) {
        for(i=0; i<this->nSites; i++) {
            for(j=0; j<this->nSites; j++) {
                labFrameSpinCorrelationFn[i][j] = 0.;
            }
        }
        return;
    }
    
    // Calculate the total of the transition probability bins
    // This will provide normalization for the spin correlations as well
    for(i=0; i<this->nSites; i++) {
        total += transProbsBins[i];
    }
    
    // Normalize spin correlation function
    if(total != 0.) {
        invTotal = 1.0L / total;
        for(i=0; i<this->nSites; i++) {
            for(j=0; j<this->nSites; j++) {
                labFrameSpinCorrelationFn[i][j] = invTotal * LabFrameSpinCorrelationBins[i][j];
            }
        }
    } else {
        for(i=0; i<this->nSites; i++) {
            for(j=0; j<this->nSites; j++) {
                labFrameSpinCorrelationFn[i][j] = 0.;
            }
        }
        cerr << "Error in holePropagationQState::calculateLabFrameSpinCorrelationFn. Spin correlation function ill defined." << endl;
        return;
    }
}

// calculate spin correlations using HoleFrameSpinCorrelationBins
// (Overwritten function!)
void holePropagationQState::calculateHoleFrameSpinCorrelationFn(vector< vector<double> > & holeFrameSpinCorrelationFn) const {
    long double total = 0.L;
    long double invTotal;
    int i,j;
    
    // Resize array and make sure it does not waste memory
    holeFrameSpinCorrelationFn.reserve(this->nSites);
    holeFrameSpinCorrelationFn.resize(this->nSites);
    for(i=0; i<nSites; i++) {
        holeFrameSpinCorrelationFn[i].resize(this->nSites);
        holeFrameSpinCorrelationFn[i].reserve(this->nSites);
    }
    
    // Calculate spin correlations only if you have to
    if(!this->calcSpinCorrelationsQ) {
        for(i=0; i<this->nSites; i++) {
            for(j=0; j<this->nSites; j++) {
                holeFrameSpinCorrelationFn[i][j] = 0.;
            }
        }
        return;
    }
    
    // Calculate the total of the transition probability bins
    // This will provide normalization for the spin correlations as well
    for(i=0; i<this->nSites; i++) {
        total += transProbsBins[i];
    }
    
    // Normalize spin correlation function
    if(total != 0.) {
        invTotal = 1.0L / total;
        for(i=0; i<this->nSites; i++) {
            for(j=0; j<this->nSites; j++) {
                holeFrameSpinCorrelationFn[i][j] = invTotal * HoleFrameSpinCorrelationBins[i][j];
            }
        }
    } else {
        for(i=0; i<this->nSites; i++) {
            for(j=0; j<this->nSites; j++) {
                holeFrameSpinCorrelationFn[i][j] = 0.;
            }
        }
        cerr << "Error in holePropagationQState::calculateholeFrameSpinCorrelationFn. Spin correlation function ill defined." << endl;
        return;
    }
}


// load the initial quantum state 'QState' we use during the simulation
bool holePropagationQState::loadQState(void) {
    bool fileExists;
    int state;
    vector<int> quantumState(this->nSites);
    
    ifstream fileBins(this->saveFilenames[9]);
    if(!fileBins.good())
        return false;
    
    int i = 0;
    while((fileBins >> state) && (i<this->nSites)) {
        quantumState[i] = state;
        i++;
    }
    
    this->QState.reset(quantumState, complex<double>(1., 0.));
    
    return true;
}


// load all three bins, using the saving functions of the parent class holePropagation
// (Overwritten function!)
bool holePropagationQState::load(void) {
    // Load the initial quantum state of the system
    if(!this->loadQState()) {
        cout << "Could not load initial quantum state from file " << this->saveFilenames[9] << endl;
        return false;
    }
    
    // Load all other data, using holePropagation::load() of the parent class.
    if(!this->holePropagation::load()) {
        return false;
    }
    
    return true;
}


// We will need to indicate in the save filenames that we do simulation in the specified quantum state,
// therefore generateSaveFilenames() is unique to the child class.
// This function will also save the quantum state we use during the simulation
// (Overwritten function!)
void holePropagationQState::generateSaveFilenames(string fnameBase) {
    stringstream fnameBaseStream;
    string fnameBaseNew;
    
    // Create the base of all the file names
    fnameBaseStream << "FixedQState_ver1_10_" << fnameBase << "_t=" << setprecision(2) << fixed << this->tHole;
    fnameBaseStream << "_lattice=" << 2*LATTICE_SIZE << "x" << 2*LATTICE_SIZE;
    fnameBaseStream << "_nPaths=" << this->nPaths;
    if(this->calcSpinCorrelationsQ) {
        fnameBaseStream << "_wSpinCorr";
    } else {
        fnameBaseStream << "_noSpinCorr";
    }
    fnameBaseNew = fnameBaseStream.str();
    
    // create all the filenames
    this->saveFilenames.resize(10);
    this->saveFilenames[0] = fnameBaseNew + "_files.txt";
    this->saveFilenames[1] = fnameBaseNew + "_params.txt";
    this->saveFilenames[2] = fnameBaseNew + "_returnProb_and_RMS.txt";
    this->saveFilenames[3] = fnameBaseNew + "_transProbs.txt";
    this->saveFilenames[4] = fnameBaseNew + "_spinCorrLabFrame.txt";
    this->saveFilenames[5] = fnameBaseNew + "_spinCorrHoleFrame.txt";
    this->saveFilenames[6] = fnameBaseNew + "_transProbsBins.txt";
    this->saveFilenames[7] = fnameBaseNew + "_spinCorrLabFrameBins.txt";
    this->saveFilenames[8] = fnameBaseNew + "_spinCorrHoleFrameBins.txt";
    this->saveFilenames[9] = fnameBaseNew + "_QState.txt";
}

// save everything, including the initial state 'QState' of the system
// (Overwritten function!)
bool holePropagationQState::save(void) const {
    bool saveOK = true;
    
    // Save the initial quantum state of the system
    saveOK = saveOK && this->saveQState();
    
    // Save all other data using the holePropagation::save() method of the parent class
    saveOK = saveOK && this->holePropagation::save();
    
    if(!saveOK) {
        cerr << "Error in holePropagationQState::save. Could not save all files." << endl;
    }
    
    return saveOK;
}


// save the initial quantum state 'QState' we use during the simulation
bool holePropagationQState::saveQState(void) const {
    // Save the initial quantum state
    string fname = this->saveFilenames[9];
    ofstream myfile (fname);
    if(!myfile.good()) {
        cerr << "Error in holePropagation::generateSaveFilenames writing to " << fname << endl << endl;
        return false;
    }
    for(int i1=0; i1<this->nSites; i1++) {
        myfile << this->QState[i1] << endl;
    }
    myfile.close();
    return true;
}


// add the values of the bins in hP to *this, and add their nRuns values
holePropagationQState & holePropagationQState::operator+= (const holePropagationQState & hP) {
    if(this->QState == hP.QState) {
        holePropagation::operator+= (hP);
    } else {
        cerr << "Error in holePropagationQState::operator+=. Different initial quantum states." << endl;
    }
    return *this;
}

// assignment operator
holePropagationQState & holePropagationQState::operator= (const holePropagationQState & hP) {
    holePropagation::operator= (hP);
    this->QState = hP.QState;
    return *this;
}



