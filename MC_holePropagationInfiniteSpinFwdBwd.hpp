//  Copyright 2017, Marton Kanasz-Nagy, All rights reserved.
//  kanasz.nagy.marton@gmail.com 
//
//  MC_holePropagationInfiniteSpinFwdBwd.hpp
//  
//
//  Created by Marton Kanasz-Nagy on 12/27/16.
//
//

#ifndef MC_holePropagationInfiniteSpinFwdBwd_hpp
#define MC_holePropagationInfiniteSpinFwdBwd_hpp


#include <stdio.h>
#include <string>
#include "MC_clusterRunQ.hpp"
#include "MC_holePropagation.hpp"

using namespace std;


// -----------------------------------------------------------------------------------------------------
// HOLE PROPAGATION IN AN INFINITE TEMPERATURE ENVIRONMENT, WITH INFINITELY MANY SPIN DEGREES OF FREEDOM
// Spin correlations are trivial in this case, therefore they are not calculated.
// -----------------------------------------------------------------------------------------------------
class holePropagationInfiniteSpinFwdBwd : public holePropagation {
    // BASIC CONSTRUCTORS AND DESTRUCTORS (constructors also initialize the random number generator)
public:
    holePropagationInfiniteSpinFwdBwd(void) : holePropagation() {
        this->generateSaveFilenames();
    };
    holePropagationInfiniteSpinFwdBwd(double t, int nFwdPaths) : holePropagation(t, nFwdPaths, false) {
        this->generateSaveFilenames();
    };
    ~holePropagationInfiniteSpinFwdBwd(void) {};
    
    // MONTE CARLO CALCULATION
public:
    // Generate new pathContainer storing the permutation cycles generated by the forward paths.
    // As there are infinitely many spin states at each site, we only get non-zero contribution
    // to the transition probabilities for a pair of paths (pwdPath and bwdPath) if they both
    // generate the same permutation on the spins. Therefore, we do not have to make pairs, just
    // add the amplitudes of all permutations in the bins of the pathContainer.
    void run(void);
    
    // same as run(void), just does not automatically generate the container, but uses 'pCFwd' and 'pCBwd' instead
    void run(const pathContainer &pCFwd, const pathContainer &pCBwd);
    
    
    
    // OVERLOADED OPERATORS
public:
    // add the values of the bins in hP to *this, and add their nRuns values if the basic parameters of hP agree with *this
    holePropagationInfiniteSpinFwdBwd & operator+= (const holePropagationInfiniteSpinFwdBwd & hP) {
        holePropagation::operator+= (hP);
        return *this;
    };
    
    // assignment operator
    holePropagationInfiniteSpinFwdBwd & operator=  (const holePropagationInfiniteSpinFwdBwd & hP) {
        holePropagation::operator= (hP);
        return *this;
    };
    
    
    
    // LOAD EARLIER BACKUP DATA
public:
    // loads parameters and returns true only if they match those of '*this'
    // (Overloaded function!)
    virtual bool loadParameters(void);
    
    // SAVE DATA
public:
    // We will need to indicate in the save filenames that we do simulation in the specified quantum state,
    // therefore generateSaveFilenames() is unique to the child class.
    // (Overwritten function!)
    void generateSaveFilenames(void);
    
    // save tHole, nPaths, LATTICE_SIZE, NUMBER_OF_SPINS, returnProbability, RMS distance, nInitialStates
    // (Overloaded function!)
    bool saveParameters(void) const;
};

#endif /* MC_holePropagationInfiniteSpinFwdBwd_hpp */
