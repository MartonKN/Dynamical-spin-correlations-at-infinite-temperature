//  Copyright 2017, Marton Kanasz-Nagy, All rights reserved.
//  kanasz.nagy.marton@gmail.com
//
//  MC_holePropagationSpinStateAvgFwdBwd.cpp
//  
//
//  Created by Marton Kanasz-Nagy on 11/19/16.
//
//

#include "MC_holePropagationSpinStateAvgFwdBwd.hpp"



// First, generate two new 'pathContainer'-s storing the permutation cycles generated by the forward and backward paths.
// Then, take 'nInitialStates' different random initial spin configurations, and transform that state using
// the paths in the containers. The benefit of this approach is that we do not need to generate the paths
// again for each new initial state, and we spare a lot of time as compared to CarlstrÃ¶m's original simulation.
void holePropagationSpinStateAvgFwdBwd::run(void) {
    // Generate path containers for forward and backward paths
    pathContainer pCfwd, pCbwd;
    
    // Fill path container with randomly generated paths
    pCfwd.fill(this->tHole, this->nPaths);
    pCbwd.fill(this->tHole, this->nPaths);
    
    // Run simulation
    this->run(pCfwd, pCbwd);
}

// same as run(void), just does not automatically generate the pathContainers, but uses 'pCfwd' and 'pCbwd' instead
void holePropagationSpinStateAvgFwdBwd::run(const pathContainer &pCfwd, const pathContainer &pCbwd) {
    int iQState;                                    // index of the quantum state we average over
    int iSite;                                      // site index
    singleHoleQState initialState;                  // randomly generated initial state of the system, with the hole at the origin
    singleHoleQStateBin qStateBinFwd, qStateBinBwd; // container storing quantum states
    set<singleHoleQState>::iterator itFwd, itBwd;   // iterator of pathData elements within cont[iSite]
    
    // Print out memory usage of the paths
    cout << endl << endl;
    cout << "Running simulation " << (this->nRuns + 1) << endl;
    cout << "Number of pathData bins: (" << pCfwd.getNumberOfBins() << ", " << pCbwd.getNumberOfBins() << ")" << endl;
    cout << "Estimated memory of path container: ";
    cout << setprecision(2) << fixed << ((pCfwd.getMemoryBytes() + pCbwd.getMemoryBytes())/(1024.*1024.)) << " MB" << endl;
    
    // Loop over initial spin configurations, and update the transition probabilities and spin correlations accordingly
    for(iQState=0; iQState<(this->nInitialStates); iQState++) {
        // generate random initial spin state
        initialState.random();
        
        // clear and then fill the bins of spin states with the permutations of 'initialState'
        for(iSite=0; iSite<(this->nSites); iSite++) {
            qStateBinFwd.fill(pCfwd[iSite], initialState);
            qStateBinBwd.fill(pCbwd[iSite], initialState);
            
            // Once we generat the spin states both for all fwd and all bwd paths, we can take the overlap of the wave functions.
            // This is simple: there is an overlap if and only if the states coincide.
            // Thus, we just need to check for each state in qStateBinFwd if it appears in qStateBinBwd.
            for(itFwd=qStateBinFwd.begin(); itFwd!=qStateBinFwd.end(); ++itFwd) {
                itBwd = qStateBinBwd.find(*itFwd);
                if(itBwd != qStateBinBwd.end()) {
                    this->update(*itFwd, *itBwd);
                }
            }
        }
        cout << ":" << flush;
    }
    cout << endl;
    
    // Update number of runs
    (this->nRuns)++;
}


// Updates the bins with contributions from the quantum states 'qSFwd' and qSBwd
// The function using this routine is supposed to make sure that the spin states in
// 'qSFwd' and 'qSBwd' are the same, and they might only differ in their coefficients.
// This is not checked in 'update' not to waste resources.
// In this class, 'update' is currently only used by 'run(const pathContainer &, const pathContainer &)'.
//
// IMPORTANT: we took something for granted during this implementation in holePropagationSpinStateAvgFwdBwd,
// to avoid having to write a large portion of new code:
// When we take the overlap of quantum states fwdState and bwdState (which are obtained from the initial state by
// transforming it using a forward and a backward path), we should update the transition probabilities and spin
// correlations by <bwdState|fwdState>. However, we update them instead only by the real part of this expression
// real(<bwdState|fwdState>). This is correct in the limit of infinitely many paths, since the imaginary
// parts should cancel out. However, this is not necessarly true in the case of finitely many paths.
// The cancelation of imaginary parts would thus be a useful sanity check.
// However, implementing this would be a huge hassle, and would require me to write a completely new base class
// instead of 'holePropagation', that could handle complex bins for the transition probabilities. Since probably
// it's not worth the time, I staid with taking the real part of the overlaps above.
double holePropagationSpinStateAvgFwdBwd::update(const singleHoleQState &qSfwd, const singleHoleQState &qSbwd) {
    // Check the coefficient is zero. Then, we don't have to do anything
    if(qSfwd.getCoefficient() == complex<double>(0.,0.) || qSbwd.getCoefficient() == complex<double>(0.,0.)) {
        return 0.;
    }
    
    long double contribution;           // contribution of this quantum state to the transition probability bins
    int holePosition;                   // position of the hole
    
    // Get position of the hole
    holePosition = qSfwd.getHolePosition();
    
    // Update transition probability bins
    complex<long double> tmp = conj(qSbwd.getCoefficient()) * qSfwd.getCoefficient();
    contribution = tmp.real();
    this->transProbsBins[holePosition] += contribution;
    
    // Update spin correlation bins
    if(this->calcSpinCorrelationsQ) {
        int i1,i2;                          // iterators
        int i1Hole, i2Hole;                 // iterators
        int x,y,xHole,yHole;                // coordinates
        int holeFrameSiteIndices[nSites];   // site indices in the hole's comoving frame
        
        xHole = indexToX(holePosition);
        yHole = indexToY(holePosition);
        
        for(i1=0; i1<nSites; i1++) {
            for(i2=0; i2<nSites; i2++) {
                LabFrameSpinCorrelationBins[i1][i2] += qSfwd[i1]*qSfwd[i2]*contribution;
            }
        }
        
        for(i1=0; i1<nSites; i1++) {
            x = indexToX(i1);
            y = indexToY(i1);
            holeFrameSiteIndices[i1] = coordToIndex(x-xHole, y-yHole);
        }
        for(i1=0; i1<nSites; i1++) {
            i1Hole = holeFrameSiteIndices[i1];
            for(i2=0; i2<nSites; i2++) {
                i2Hole = holeFrameSiteIndices[i2];
                HoleFrameSpinCorrelationBins[i1Hole][i2Hole] += qSfwd[i1]*qSfwd[i2]*contribution;
            }
        }
    }
    
    return contribution;
}


// calculate spin correlations using LabFrameSpinCorrelationBins (Overwritten function!)
void holePropagationSpinStateAvgFwdBwd::calculateLabFrameSpinCorrelationFn (vector< vector<double> > &labFrameSpinCorrelationFn) const {
    long double total = 0.L;
    long double invTotal;
    int i,j;
    
    // Resize array and make sure it does not waste memory
    labFrameSpinCorrelationFn.reserve(nSites);
    labFrameSpinCorrelationFn.resize(nSites);
    for(i=0; i<nSites; i++) {
        labFrameSpinCorrelationFn[i].reserve(nSites);
        labFrameSpinCorrelationFn[i].resize(nSites);
    }
    
    // Calculate spin correlations only if you have to
    if(!this->calcSpinCorrelationsQ) {
        for(i=0; i<this->nSites; i++) {
            for(j=0; j<this->nSites; j++) {
                labFrameSpinCorrelationFn[i][j] = 0.;
            }
        }
        return;
    }
    
    // Calculate the total of the transition probability bins
    // This will provide normalization for the spin correlations as well
    for(i=0; i<nSites; i++) {
        total += transProbsBins[i];
    }
    
    // Normalize spin correlation function
    if(total != 0.) {
        invTotal = 1.0L / total;
        for(i=0; i<nSites; i++) {
            for(j=0; j<nSites; j++) {
                labFrameSpinCorrelationFn[i][j] = invTotal * LabFrameSpinCorrelationBins[i][j];
            }
        }
    } else {
        for(i=0; i<nSites; i++) {
            for(j=0; j<nSites; j++) {
                labFrameSpinCorrelationFn[i][j] = 0.;
            }
        }
        cerr << "Error in holePropagationQState::calculateLabFrameSpinCorrelationFn. Spin correlation function ill defined." << endl;
        return;
    }
}

// calculate spin correlations using HoleFrameSpinCorrelationBins (Overwritten function!)
void holePropagationSpinStateAvgFwdBwd::calculateHoleFrameSpinCorrelationFn(vector< vector<double> > & holeFrameSpinCorrelationFn) const {
    long double total = 0.L;
    long double invTotal;
    int i,j;
    
    // Resize array and make sure it does not waste memory
    holeFrameSpinCorrelationFn.reserve(nSites);
    holeFrameSpinCorrelationFn.resize(nSites);
    for(i=0; i<nSites; i++) {
        holeFrameSpinCorrelationFn[i].resize(nSites);
        holeFrameSpinCorrelationFn[i].reserve(nSites);
    }
    
    // Calculate spin correlations only if you have to
    if(!this->calcSpinCorrelationsQ) {
        for(i=0; i<this->nSites; i++) {
            for(j=0; j<this->nSites; j++) {
                holeFrameSpinCorrelationFn[i][j] = 0.;
            }
        }
        return;
    }
    
    // Calculate the total of the transition probability bins
    // This will provide normalization for the spin correlations as well
    for(i=0; i<nSites; i++) {
        total += transProbsBins[i];
    }
    
    // Normalize spin correlation function
    if(total != 0.) {
        invTotal = 1.0L / total;
        for(i=0; i<nSites; i++) {
            for(j=0; j<nSites; j++) {
                holeFrameSpinCorrelationFn[i][j] = invTotal * HoleFrameSpinCorrelationBins[i][j];
            }
        }
    } else {
        for(i=0; i<nSites; i++) {
            for(j=0; j<nSites; j++) {
                holeFrameSpinCorrelationFn[i][j] = 0.;
            }
        }
        cerr << "Error in holePropagationQState::calculateholeFrameSpinCorrelationFn. Spin correlation function ill defined." << endl;
        return;
    }
}

// add the values of the bins in hP to *this, and add their nRuns values if the basic parameters of hP agree with *this
holePropagationSpinStateAvgFwdBwd & holePropagationSpinStateAvgFwdBwd::operator+= (const holePropagationSpinStateAvgFwdBwd & hP) {
    if(this->nInitialStates == hP.nInitialStates) {
        holePropagation::operator+= (hP);
    } else {
        cerr << "Error in holePropagationSpinStateAvgFwdBwd::operator+=. The number of initial states is different." << endl;
    }
    
    return *this;
}

// assignment operator
holePropagationSpinStateAvgFwdBwd & holePropagationSpinStateAvgFwdBwd::operator=  (const holePropagationSpinStateAvgFwdBwd & hP) {
    holePropagation::operator= (hP);
    this->nInitialStates = hP.nInitialStates;
    return *this;
}

// loads parameters and returns true only if they match those of '*this'
// (Overloaded function!)
bool holePropagationSpinStateAvgFwdBwd::loadParameters(void) {
    string fname = saveFilenames[1];
    string line;
    ifstream myfile(fname);
    
    // Data we read from the file
    double tHole_FromFile;
    int nPaths_FromFile;
    int LATTICE_SIZE_FromFile;
    int NUMBER_OF_SPINS_FromFile;
    double runs_finished_FromFile;
    double returnProb_FromFile;
    double RMS_distance_FromFile;
    int nInitialStates_FromFile;
    
    // Check if file exists and could be opened
    if(!myfile.good()) {
        return false;
    }
    
    // First line is just comments
    if(!getline(myfile, line))
        return false;
    
    // Second line contains the data in the following order: time, nPaths, LATTICE_SIZE, NUMBER_OF_SPINS
    if(!getline(myfile, line))
        return false;
    
    // Read data
    istringstream stream(line);
    stream >> tHole_FromFile;
    stream >> nPaths_FromFile;
    stream >> LATTICE_SIZE_FromFile;
    stream >> NUMBER_OF_SPINS_FromFile;
    stream >> runs_finished_FromFile;
    stream >> returnProb_FromFile;
    stream >> RMS_distance_FromFile;
    stream >> nInitialStates_FromFile;
    
    
    // Check if it is the same as the one we have in *this
    // If any of the data members are incorrect, return false
    if(tHole_FromFile != this->tHole)
        return false;
    if(nPaths_FromFile != this->nPaths)
        return false;
    if(LATTICE_SIZE_FromFile != LATTICE_SIZE)
        return false;
    if(NUMBER_OF_SPINS_FromFile != this->NUMBER_OF_SPINS)
        return false;
    if(nInitialStates_FromFile != this->nInitialStates)
        return false;
    
    myfile.close();
    
    // If everything went well, return true
    return true;
}

// We will need to indicate in the save filenames that we do simulation in the specified quantum state,
// therefore generateSaveFilenames() is unique to the child class.
// (Overwritten function!)
void holePropagationSpinStateAvgFwdBwd::generateSaveFilenames() {
    stringstream fnameBaseStream;
    string fnameBaseNew;
    
    // Create the base of all the file names
    fnameBaseStream << "InfiniteTSpinStateAvgFwdBwd_ver1_10_t=" << setprecision(2) << fixed << this->tHole;
    fnameBaseStream << "_lattice=" << 2*LATTICE_SIZE << "x" << 2*LATTICE_SIZE;
    fnameBaseStream << "_nPaths=" << this->nPaths;
    fnameBaseStream << "_nStates=" << this->nInitialStates;
    if(this->calcSpinCorrelationsQ) {
        fnameBaseStream << "_wSpinCorr";
    } else {
        fnameBaseStream << "_noSpinCorr";
    }
    fnameBaseNew = fnameBaseStream.str();
    
    // create all the filenames
    this->saveFilenames.resize(9);
    this->saveFilenames[0] = fnameBaseNew + "_files.txt";
    this->saveFilenames[1] = fnameBaseNew + "_params.txt";
    this->saveFilenames[2] = fnameBaseNew + "_returnProb_and_RMS.txt";
    this->saveFilenames[3] = fnameBaseNew + "_transProbs.txt";
    this->saveFilenames[4] = fnameBaseNew + "_spinCorrLabFrame.txt";
    this->saveFilenames[5] = fnameBaseNew + "_spinCorrHoleFrame.txt";
    this->saveFilenames[6] = fnameBaseNew + "_transProbsBins.txt";
    this->saveFilenames[7] = fnameBaseNew + "_spinCorrLabFrameBins.txt";
    this->saveFilenames[8] = fnameBaseNew + "_spinCorrHoleFrameBins.txt";
}

// save tHole, nPaths, LATTICE_SIZE, NUMBER_OF_SPINS, returnProbability, RMS distance, nInitialStates
// (Overloaded function!)
bool holePropagationSpinStateAvgFwdBwd::saveParameters(void) const {
    string fname = this->saveFilenames[1];
    ofstream myfile (fname);
    if(!myfile) {
        cerr << "Error in holePropagation::saveParameters writing to " << fname << endl << endl;
        return false;
    }
    
    myfile << "# time \t #paths \t LATTICE_SIZE \t NUMBER_OF_SPINS \t #runs_finished \t ";
    myfile << "return_probability \t RMS_distance \t nInitialStates" << endl;
    myfile << this->tHole << "\t";
    myfile << this->nPaths << "\t";
    myfile << LATTICE_SIZE << "\t";
    myfile << this->NUMBER_OF_SPINS << "\t";
    myfile << this->nRuns << "\t";
    myfile << this->getReturnProbability() << "\t";
    myfile << this->getRMSdistance() << "\t";
    myfile << this->getNumberOfInitialStates();
    myfile << endl;
    
    myfile.close();
    
    return true;
}
