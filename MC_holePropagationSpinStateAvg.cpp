//  Copyright 2017, Marton Kanasz-Nagy, All rights reserved.
//  kanasz.nagy.marton@gmail.com
//
//  MC_holePropagationSpinStateAvg.cpp
//  
//
//  Created by Marton Kanasz-Nagy on 10/19/16.
//
//

#include "MC_holePropagationSpinStateAvg.hpp"

// First, generate new pathContainer storing the permutation cycles generated by the forward paths
// Then, take 'nInitialStates' different random initial spin configurations, and transform that state using
// the paths in the container. The benefit of this approach is that we do not need to generate the paths
// again for each new initial state, and we spare a lot of time as compared to CarlstrÃ¶m's original simulation.
// Furthermore, it is expected to be faster than our previous simulation as well, when the number of paths is
// large. That simulation suffered from the problem that we had to take pairs of paths to calculate the transition
// probabilities, which was not feasible once the number of paths became of the order of 100K.
// In contrast, in the current simulation, the number of quantum states that we generate is only of the
// order of the paths (~50% of them), and we do not need to take pairs.
void holePropagationSpinStateAvg::run(void) {
    // Generate path container
    pathContainer pC;
    
    // Fill path container with randomly generated paths
    pC.fill(this->tHole, this->nPaths);
    
    // Run simulation
    this->run(pC);
}

// same as run(void), just does not automatically generate the container, but uses 'qSC' instead
void holePropagationSpinStateAvg::run(const pathContainer &pC) {
    int iQState;                                // index of the quantum state we average over
    int iSite;                                  // site index
    singleHoleQState initialState;              // randomly generated initial state of the system, with the hole at the origin
    singleHoleQStateContainer qStateCont;       // container storing quantum states
    set<singleHoleQState>::iterator it;         // iterator of pathData elements within cont[iSite]
    
    // Print out memory usage of the paths
    cout << endl << endl;
    cout << "Running simulation " << (this->nRuns + 1) << endl;
    cout << "Number of pathData bins: " << pC.getNumberOfBins() << endl;
    cout << "Estimated memory of path container: " << setprecision(2) << fixed << (pC.getMemoryBytes()/(1024.*1024.)) << " MB" << endl;
    
    // Loop over initial spin configurations, and update the transition probabilities and spin correlations accordingly
    for(iQState=0; iQState<this->nInitialStates; iQState++) {
        // generate random initial spin state
        initialState.random();
        
        // clear and then fill the bin of spin states with the permutations of 'initialState'
        qStateCont.fill(pC, initialState);
        
        // Loop over all sites, as well as all pairs of paths within the container at that site, and update *this accordingly
        for(iSite=0; iSite<(this->nSites); iSite++) {
            for(it=qStateCont[iSite].begin(); it!=qStateCont[iSite].end(); ++it) {
                this->update(*it);
            }
        }
        cout << ":" << flush;
    }
    cout << endl;
    
    // Update number of runs
    (this->nRuns)++;
}


// Updates the bins with contributions from the quantumState 'qS'
double holePropagationSpinStateAvg::update(const singleHoleQState &qS) {
    // Check the coefficient is zero. Then, we don't have to do anything
    if(qS.getCoefficient() == complex<double>(0.,0.)) {
        return 0.;
    }
    
    long double contribution;           // contribution of this quantum state to the transition probability bins
    int holePosition;                   // position of the hole
    
    // Get position of the hole
    holePosition = qS.getHolePosition();
    
    // Update transition probability bins
    complex<long double> tmp;
    tmp = qS.getCoefficient();
    tmp = conj(tmp) * tmp;
    contribution = tmp.real();
    this->transProbsBins[holePosition] += contribution;
    
    // Update spin correlation bins
    if(this->calcSpinCorrelationsQ) {
        int i1,i2;                          // iterators
        int i1Hole, i2Hole;                 // iterators
        int x,y,xHole,yHole;                // coordinates
        int holeFrameSiteIndices[nSites];   // site indices in the hole's comoving frame
        
        xHole = indexToX(holePosition);
        yHole = indexToY(holePosition);
        
        for(i1=0; i1<nSites; i1++) {
            for(i2=0; i2<nSites; i2++) {
                LabFrameSpinCorrelationBins[i1][i2] += qS[i1]*qS[i2]*contribution;
            }
        }
        
        for(i1=0; i1<nSites; i1++) {
            x = indexToX(i1);
            y = indexToY(i1);
            holeFrameSiteIndices[i1] = coordToIndex(x-xHole, y-yHole);
        }
        for(i1=0; i1<nSites; i1++) {
            i1Hole = holeFrameSiteIndices[i1];
            for(i2=0; i2<nSites; i2++) {
                i2Hole = holeFrameSiteIndices[i2];
                HoleFrameSpinCorrelationBins[i1Hole][i2Hole] += qS[i1]*qS[i2]*contribution;
            }
        }
    }
    
    return contribution;
}


// calculate spin correlations using LabFrameSpinCorrelationBins (Overwritten function!)
void holePropagationSpinStateAvg::calculateLabFrameSpinCorrelationFn (vector< vector<double> > &labFrameSpinCorrelationFn) const {
    long double total = 0.L;
    long double invTotal;
    int i,j;
    
    // Resize array and make sure it does not waste memory
    labFrameSpinCorrelationFn.reserve(nSites);
    labFrameSpinCorrelationFn.resize(nSites);
    for(i=0; i<nSites; i++) {
        labFrameSpinCorrelationFn[i].reserve(nSites);
        labFrameSpinCorrelationFn[i].resize(nSites);
    }
    
    // Calculate spin correlations only if you have to
    if(!this->calcSpinCorrelationsQ) {
        for(i=0; i<this->nSites; i++) {
            for(j=0; j<this->nSites; j++) {
                labFrameSpinCorrelationFn[i][j] = 0.;
            }
        }
        return;
    }
    
    // Calculate the total of the transition probability bins
    // This will provide normalization for the spin correlations as well
    for(i=0; i<nSites; i++) {
        total += transProbsBins[i];
    }
    
    // Normalize spin correlation function
    if(total != 0.) {
        invTotal = 1.0L / total;
        for(i=0; i<nSites; i++) {
            for(j=0; j<nSites; j++) {
                labFrameSpinCorrelationFn[i][j] = invTotal * LabFrameSpinCorrelationBins[i][j];
            }
        }
    } else {
        for(i=0; i<nSites; i++) {
            for(j=0; j<nSites; j++) {
                labFrameSpinCorrelationFn[i][j] = 0.;
            }
        }
        cerr << "Error in holePropagationQState::calculateLabFrameSpinCorrelationFn. Spin correlation function ill defined." << endl;
        return;
    }
}

// calculate spin correlations using HoleFrameSpinCorrelationBins (Overwritten function!)
void holePropagationSpinStateAvg::calculateHoleFrameSpinCorrelationFn(vector< vector<double> > & holeFrameSpinCorrelationFn) const {
    long double total = 0.L;
    long double invTotal;
    int i,j;
    
    // Resize array and make sure it does not waste memory
    holeFrameSpinCorrelationFn.reserve(nSites);
    holeFrameSpinCorrelationFn.resize(nSites);
    for(i=0; i<nSites; i++) {
        holeFrameSpinCorrelationFn[i].resize(nSites);
        holeFrameSpinCorrelationFn[i].reserve(nSites);
    }
    
    // Calculate spin correlations only if you have to
    if(!this->calcSpinCorrelationsQ) {
        for(i=0; i<this->nSites; i++) {
            for(j=0; j<this->nSites; j++) {
                holeFrameSpinCorrelationFn[i][j] = 0.;
            }
        }
        return;
    }
    
    // Calculate the total of the transition probability bins
    // This will provide normalization for the spin correlations as well
    for(i=0; i<nSites; i++) {
        total += transProbsBins[i];
    }
    
    // Normalize spin correlation function
    if(total != 0.) {
        invTotal = 1.0L / total;
        for(i=0; i<nSites; i++) {
            for(j=0; j<nSites; j++) {
                holeFrameSpinCorrelationFn[i][j] = invTotal * HoleFrameSpinCorrelationBins[i][j];
            }
        }
    } else {
        for(i=0; i<nSites; i++) {
            for(j=0; j<nSites; j++) {
                holeFrameSpinCorrelationFn[i][j] = 0.;
            }
        }
        cerr << "Error in holePropagationQState::calculateholeFrameSpinCorrelationFn. Spin correlation function ill defined." << endl;
        return;
    }
}

// add the values of the bins in hP to *this, and add their nRuns values if the basic parameters of hP agree with *this
holePropagationSpinStateAvg & holePropagationSpinStateAvg::operator+= (const holePropagationSpinStateAvg & hP) {
    if(this->nInitialStates == hP.nInitialStates) {
        holePropagation::operator+= (hP);
    } else {
        cerr << "Error in holePropagationSpinStateAvg::operator+=. The number of initial states is different." << endl;
    }
    
    return *this;
}

// assignment operator
holePropagationSpinStateAvg & holePropagationSpinStateAvg::operator=  (const holePropagationSpinStateAvg & hP) {
    holePropagation::operator= (hP);
    this->nInitialStates = hP.nInitialStates;
    return *this;
}

// loads parameters and returns true only if they match those of '*this'
// (Overloaded function!)
bool holePropagationSpinStateAvg::loadParameters(void) {
    string fname = saveFilenames[1];
    string line;
    ifstream myfile(fname);
    
    // Data we read from the file
    double tHole_FromFile;
    int nPaths_FromFile;
    int LATTICE_SIZE_FromFile;
    int NUMBER_OF_SPINS_FromFile;
    double runs_finished_FromFile;
    double returnProb_FromFile;
    double RMS_distance_FromFile;
    int nInitialStates_FromFile;
    
    // Check if file exists and could be opened
    if(!myfile.good()) {
        return false;
    }
    
    // First line is just comments
    if(!getline(myfile, line))
        return false;
    
    // Second line contains the data in the following order: time, nPaths, LATTICE_SIZE, NUMBER_OF_SPINS
    if(!getline(myfile, line))
        return false;
    
    // Read data
    istringstream stream(line);
    stream >> tHole_FromFile;
    stream >> nPaths_FromFile;
    stream >> LATTICE_SIZE_FromFile;
    stream >> NUMBER_OF_SPINS_FromFile;
    stream >> runs_finished_FromFile;
    stream >> returnProb_FromFile;
    stream >> RMS_distance_FromFile;
    stream >> nInitialStates_FromFile;
    
    
    // Check if it is the same as the one we have in *this
    // If any of the data members are incorrect, return false
    if(tHole_FromFile != this->tHole)
        return false;
    if(nPaths_FromFile != this->nPaths)
        return false;
    if(LATTICE_SIZE_FromFile != LATTICE_SIZE)
        return false;
    if(NUMBER_OF_SPINS_FromFile != this->NUMBER_OF_SPINS)
        return false;
    if(nInitialStates_FromFile != this->nInitialStates)
        return false;
    
    myfile.close();
    
    // If everything went well, return true
    return true;
}

// We will need to indicate in the save filenames that we do simulation in the specified quantum state,
// therefore generateSaveFilenames() is unique to the child class.
// (Overwritten function!)
void holePropagationSpinStateAvg::generateSaveFilenames() {
    stringstream fnameBaseStream;
    string fnameBaseNew;
    
    // Create the base of all the file names
    fnameBaseStream << "InfiniteTSpinStateAvg_ver1_10_t=" << setprecision(2) << fixed << this->tHole;
    fnameBaseStream << "_lattice=" << 2*LATTICE_SIZE << "x" << 2*LATTICE_SIZE;
    fnameBaseStream << "_nPaths=" << this->nPaths;
    fnameBaseStream << "_nStates=" << this->nInitialStates;
    if(this->calcSpinCorrelationsQ) {
        fnameBaseStream << "_wSpinCorr";
    } else {
        fnameBaseStream << "_noSpinCorr";
    }
    fnameBaseNew = fnameBaseStream.str();
    
    // create all the filenames
    this->saveFilenames.resize(9);
    this->saveFilenames[0] = fnameBaseNew + "_files.txt";
    this->saveFilenames[1] = fnameBaseNew + "_params.txt";
    this->saveFilenames[2] = fnameBaseNew + "_returnProb_and_RMS.txt";
    this->saveFilenames[3] = fnameBaseNew + "_transProbs.txt";
    this->saveFilenames[4] = fnameBaseNew + "_spinCorrLabFrame.txt";
    this->saveFilenames[5] = fnameBaseNew + "_spinCorrHoleFrame.txt";
    this->saveFilenames[6] = fnameBaseNew + "_transProbsBins.txt";
    this->saveFilenames[7] = fnameBaseNew + "_spinCorrLabFrameBins.txt";
    this->saveFilenames[8] = fnameBaseNew + "_spinCorrHoleFrameBins.txt";
}

// save tHole, nPaths, LATTICE_SIZE, NUMBER_OF_SPINS, returnProbability, RMS distance, nInitialStates
// (Overloaded function!)
bool holePropagationSpinStateAvg::saveParameters(void) const {
    string fname = this->saveFilenames[1];
    ofstream myfile (fname);
    if(!myfile) {
        cerr << "Error in holePropagation::saveParameters writing to " << fname << endl << endl;
        return false;
    }
    
    myfile << "# time \t #paths \t LATTICE_SIZE \t NUMBER_OF_SPINS \t #runs_finished \t ";
    myfile << "return_probability \t RMS_distance \t nInitialStates" << endl;
    myfile << this->tHole << "\t";
    myfile << this->nPaths << "\t";
    myfile << LATTICE_SIZE << "\t";
    myfile << this->NUMBER_OF_SPINS << "\t";
    myfile << this->nRuns << "\t";
    myfile << this->getReturnProbability() << "\t";
    myfile << this->getRMSdistance() << "\t";
    myfile << this->getNumberOfInitialStates();
    myfile << endl;
    
    myfile.close();
    
    return true;
}
