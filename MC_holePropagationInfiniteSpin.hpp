//  Copyright 2017, Marton Kanasz-Nagy, All rights reserved.
//  kanasz.nagy.marton@gmail.com 
//
//  MC_holePropagationInfiniteSpin.hpp
//  
//
//  Created by Marton Kanasz-Nagy on 11/14/16.
//
//

#ifndef MC_holePropagationInfiniteSpin_hpp
#define MC_holePropagationInfiniteSpin_hpp

#include <stdio.h>
#include <string>
#include "MC_clusterRunQ.hpp"
#include "MC_holePropagation.hpp"

using namespace std;


// -----------------------------------------------------------------------------------------------------
// HOLE PROPAGATION IN AN INFINITE TEMPERATURE ENVIRONMENT, WITH INFINITELY MANY SPIN DEGREES OF FREEDOM
// Spin correlations are trivial in this case, therefore they are not calculated.
// -----------------------------------------------------------------------------------------------------
class holePropagationInfiniteSpin : public holePropagation {
    // BASIC CONSTRUCTORS AND DESTRUCTORS (constructors also initialize the random number generator)
public:
    holePropagationInfiniteSpin(void) : holePropagation() {
        this->generateSaveFilenames();
    };
    holePropagationInfiniteSpin(double t, int nFwdPaths) : holePropagation(t, nFwdPaths, false) {
        this->generateSaveFilenames();
    };
    ~holePropagationInfiniteSpin(void) {};
    
    // MONTE CARLO CALCULATION
public:
    // Generate new pathContainer storing the permutation cycles generated by the forward paths.
    // As there are infinitely many spin states at each site, we only get non-zero contribution
    // to the transition probabilities for a pair of paths (pwdPath and bwdPath) if they both
    // generate the same permutation on the spins. Therefore, we do not have to make pairs, just
    // add the amplitudes of all permutations in the bins of the pathContainer.
    void run(void);
    
    // same as run(void), just does not automatically generate the container, but uses 'pC' instead
    void run(const pathContainer &pC);
    
    
    
    // OVERLOADED OPERATORS
public:
    // add the values of the bins in hP to *this, and add their nRuns values if the basic parameters of hP agree with *this
    holePropagationInfiniteSpin & operator+= (const holePropagationInfiniteSpin & hP) {
        holePropagation::operator+= (hP);
        return *this;
    };
    
    // assignment operator
    holePropagationInfiniteSpin & operator=  (const holePropagationInfiniteSpin & hP) {
        holePropagation::operator= (hP);
        return *this;
    };
    
    
    
    // LOAD EARLIER BACKUP DATA
public:
    // loads parameters and returns true only if they match those of '*this'
    // (Overloaded function!)
    virtual bool loadParameters(void);
    
    // SAVE DATA
public:
    // We will need to indicate in the save filenames that we do simulation in the specified quantum state,
    // therefore generateSaveFilenames() is unique to the child class.
    // (Overwritten function!)
    void generateSaveFilenames(void);
    
    // save tHole, nPaths, LATTICE_SIZE, NUMBER_OF_SPINS, returnProbability, RMS distance, nInitialStates
    // (Overloaded function!)
    bool saveParameters(void) const;
};


#endif /* MC_holePropagationInfiniteSpin_hpp */
