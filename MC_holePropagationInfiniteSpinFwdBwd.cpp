//  Copyright 2017, Marton Kanasz-Nagy, All rights reserved.
//  kanasz.nagy.marton@gmail.com
//
//  MC_holePropagationInfiniteSpinFwdBwd.cpp
//  
//
//  Created by Marton Kanasz-Nagy on 12/27/16.
//
//

#include "MC_holePropagationInfiniteSpinFwdBwd.hpp"



// Generate new pathContainer storing the permutation cycles generated by the forward paths.
// As there are infinitely many spin states at each site, we only get non-zero contribution
// to the transition probabilities for a pair of paths (pwdPath and bwdPath) if they both
// generate the same permutation on the spins. Therefore, we do not have to make pairs, just
// add the amplitudes of all permutations in the bins of the pathContainer.
void holePropagationInfiniteSpinFwdBwd::run(void) {
    // Generate path container of forward and backward paths
    pathContainer pCFwd, pCBwd;
    
    // Fill path containers with randomly generated paths
    pCFwd.fill(this->tHole, this->nPaths);
    pCBwd.fill(this->tHole, this->nPaths);
    
    // Run simulation
    this->run(pCFwd, pCBwd);
}

// same as run(void), just does not automatically generate the container, but uses 'qSC' instead
void holePropagationInfiniteSpinFwdBwd::run(const pathContainer &pCFwd, const pathContainer &pCBwd) {
    int iSite;                            // site index
    set<pathData>::iterator itFwd, itBwd; // iterator of pathData elements within pC[iSite]
    complex<long double> contribution;    // temporary variable to store contribution of each class of paths to the transition probability
    
    // Print out memory usage of the paths
    cout << endl << endl;
    cout << "Running simulation " << (this->nRuns + 1) << endl;
    cout << "Number of pathData bins: (" << pCFwd.getNumberOfBins() << ", " << pCBwd.getNumberOfBins() << ")" << endl;
    cout << "Estimated memory of path container: " << setprecision(2) << fixed << ((pCFwd.getMemoryBytes() + pCBwd.getMemoryBytes())/(1024.*1024.)) << " MB" << endl;
    
    // Loop over all sites, as well as all pairs of paths within the container at that site, and update *this accordingly
    for(iSite=0; iSite<(this->nSites); iSite++) {
        for(itFwd=pCFwd[iSite].begin(); itFwd!=pCFwd[iSite].end(); ++itFwd) {
            itBwd = pCBwd[iSite].find(*itFwd);
            if(itBwd != pCBwd[iSite].end()) {
                contribution = conj((*itBwd).getCoefficient()) * (*itFwd).getCoefficient();
            }
            transProbsBins[iSite] += contribution.real();
        }
    }
    cout << endl;
    
    // Update number of runs
    (this->nRuns)++;
}


// loads parameters and returns true only if they match those of '*this'
// (Overloaded function!)
bool holePropagationInfiniteSpinFwdBwd::loadParameters(void) {
    string fname = saveFilenames[1];
    string line;
    ifstream myfile(fname);
    
    // Data we read from the file
    double tHole_FromFile;
    int nPaths_FromFile;
    int LATTICE_SIZE_FromFile;
    string NUMBER_OF_SPINS_FromFile;
    double runs_finished_FromFile;
    double returnProb_FromFile;
    double RMS_distance_FromFile;
    
    // Check if file exists and could be opened
    if(!myfile.good()) {
        return false;
    }
    
    // First line is just comments
    if(!getline(myfile, line))
        return false;
    
    // Second line contains the data in the following order: time, nPaths, LATTICE_SIZE, NUMBER_OF_SPINS
    if(!getline(myfile, line))
        return false;
    
    // Read data
    istringstream stream(line);
    stream >> tHole_FromFile;
    stream >> nPaths_FromFile;
    stream >> LATTICE_SIZE_FromFile;
    stream >> NUMBER_OF_SPINS_FromFile;
    stream >> runs_finished_FromFile;
    stream >> returnProb_FromFile;
    stream >> RMS_distance_FromFile;
    
    
    // Check if it is the same as the one we have in *this
    // If any of the data members are incorrect, return false
    if(tHole_FromFile != this->tHole)
        return false;
    if(nPaths_FromFile != this->nPaths)
        return false;
    if(LATTICE_SIZE_FromFile != LATTICE_SIZE)
        return false;
    if(NUMBER_OF_SPINS_FromFile.compare("inf") != 0)
        return false;
    
    myfile.close();
    
    // If everything went well, return true
    return true;
}

// We will need to indicate in the save filenames that we do simulation in the specified quantum state,
// therefore generateSaveFilenames() is unique to the child class.
// (Overwritten function!)
void holePropagationInfiniteSpinFwdBwd::generateSaveFilenames() {
    stringstream fnameBaseStream;
    string fnameBaseNew;
    
    // Create the base of all the file names
    fnameBaseStream << "InfiniteT_InfiniteSpinFwdBwd_ver1_10_t=" << setprecision(2) << fixed << this->tHole;
    fnameBaseStream << "_lattice=" << 2*LATTICE_SIZE << "x" << 2*LATTICE_SIZE;
    fnameBaseStream << "_nPaths=" << this->nPaths;
    fnameBaseNew = fnameBaseStream.str();
    
    // create all the filenames
    this->saveFilenames.resize(9);
    this->saveFilenames[0] = fnameBaseNew + "_files.txt";
    this->saveFilenames[1] = fnameBaseNew + "_params.txt";
    this->saveFilenames[2] = fnameBaseNew + "_returnProb_and_RMS.txt";
    this->saveFilenames[3] = fnameBaseNew + "_transProbs.txt";
    this->saveFilenames[4] = fnameBaseNew + "_spinCorrLabFrame.txt";
    this->saveFilenames[5] = fnameBaseNew + "_spinCorrHoleFrame.txt";
    this->saveFilenames[6] = fnameBaseNew + "_transProbsBins.txt";
    this->saveFilenames[7] = fnameBaseNew + "_spinCorrLabFrameBins.txt";
    this->saveFilenames[8] = fnameBaseNew + "_spinCorrHoleFrameBins.txt";
}

// save tHole, nPaths, LATTICE_SIZE, NUMBER_OF_SPINS, returnProbability, RMS distance, nInitialStates
// (Overloaded function!)
bool holePropagationInfiniteSpinFwdBwd::saveParameters(void) const {
    string fname = this->saveFilenames[1];
    ofstream myfile (fname);
    if(!myfile) {
        cerr << "Error in holePropagationInfiniteSpinFwdBwd::saveParameters writing to " << fname << endl << endl;
        return false;
    }
    
    myfile << "# time \t #paths \t LATTICE_SIZE \t NUMBER_OF_SPINS \t #runs_finished \t ";
    myfile << "return_probability \t RMS_distance" << endl;
    myfile << this->tHole << "\t";
    myfile << this->nPaths << "\t";
    myfile << LATTICE_SIZE << "\t";
    myfile << "inf" << "\t";
    myfile << this->nRuns << "\t";
    myfile << this->getReturnProbability() << "\t";
    myfile << this->getRMSdistance() << "\t";
    myfile << endl;
    
    myfile.close();
    
    return true;
}
